#!/usr/bin/env python
# -*- coding:utf-8 -*-

"""
# File       : cli.py
# Time       ：2025/10/1 12:58
# Author     ：Jago
# Email      ：huwl@hku.hk
# Description：replace the original cli.py with this script and just run
Main difference compared with https://github.com/warpem/warp-tm-vis/blob/main/src/warp_tm_vis/cli.py
changed line "import rich" to "from rich.console import Console"
changed line "console = rich.console.Concole()" to "console = Console()"

changed a lot of add_tomogram function
added get_absolute_particle_positions function

added --load_correlation_volumes and --bin parameters, customized many parameters for SMV dataset
"""
from enum import Enum
from pathlib import Path
from typing import Optional, List

import mrcfile
import napari
import napari.utils.notifications
import numpy as np
import starfile
# ref https://github.com/warpem/warp-tm-vis/issues/9
from rich.console import Console
import typer
from magicgui import magicgui

from .utils import (
    find_correlation_volume_file,
    update_volume_layers,
    update_particle_layer,
    get_particle_positions_and_cc,
    find_particles_file
)

console = Console()

cli = typer.Typer(add_completion=False)


def get_absolute_particle_positions(tomogram_file: str, particle_files: list[Path]) -> np.ndarray:
    df = starfile.read(find_particles_file(Path(tomogram_file), particle_files=particle_files))
    zyx = df[['rlnCoordinateZ', 'rlnCoordinateY', 'rlnCoordinateX']].to_numpy()
    return zyx

@cli.command(
    no_args_is_help=True,
    help="Visualize Warp template matching results and the effects of thresholding.\n"
         "if cvp not provided, will read absolute particle coordinates from particles .star files "
         "(Not the relative coordinates in [0,1] generated by Warp).\nchanged by Wanlong 20251001"
)
def warp_tm_vis(
    reconstruction_directory: Path = typer.Option(
        ...,
        '--reconstruction-directory', '-rdir',
        help="directory containing tomograms e.g. warp_tiltseries/reconstruction/deconv"
    ),
    matching_directory: Path = typer.Option(
        ...,
        '--matching-directory', '-mdir',
        help="matching directory e.g. warp_tiltseries/matching"
    ),
    matching_pattern: str = typer.Option(
        "*.star",
        '--matching-pattern', '-mp',
        help="matching pattern e.g. \"*_flipx.star\""
    ),
    correlation_volume_pattern: Optional[str] = typer.Option(
        None,
        '--correlation-volume-pattern', '-cvp',
        help="correlation volume pattern e.g. \"*_flipx_corr.mrc\" (if not provided, wont load correlation volumes)"
    ),
    bin: Optional[int] = typer.Option(
        2,
        '--bin', '-b',
        help="binning factor applied to both the tomogram and particle coordinates in case of OOM"
    ),
    load_volumes: bool = typer.Option(
        default=True,
        help="whether or not to load reconstructions"
    ),
    load_correlation_volumes: bool = typer.Option(
        default=True,
        help="whether or not to load correlation volumes (overridden to False if no correlation pattern)"
    ),
):
    # grab files
    mp = matching_pattern or "*.star"
    particle_files = list(matching_directory.glob(mp))
    tomogram_files = list(reconstruction_directory.glob('*.mrc'))

    console.log(f"found {len(particle_files)} particle files")
    console.log(f"found {len(tomogram_files)} tomogrvimam files")

    # correlation volume files only if user provided a pattern
    correlation_volume_files: List[Path] = []
    if correlation_volume_pattern:
        correlation_volume_files = list(matching_directory.glob(correlation_volume_pattern))
        console.log(f"found {len(correlation_volume_files)} correlation volume files")
    else:
        if load_correlation_volumes:
            console.log("No correlation-volume pattern provided -> only display particle positions.")
            load_correlation_volumes = False

    with console.status("launching napari viewer...", spinner="arc"):
        viewer = napari.Viewer(ndisplay=3)
    console.log("napari viewer launched")

    viewer.title = "warp-tm-vis"

    tomogram_files = [str(path) for path in tomogram_files]
    Tomogram = Enum('Tomogram', ' '.join(tomogram_files))

    @magicgui(auto_call=True)
    def add_tomogram(tomogram: Tomogram):
        # load volumes
        if load_volumes:
            console.log(f"loading tomogram from {tomogram}...")
            volume = mrcfile.read(tomogram.name)
            console.log(f"tomogram loaded")

        if load_correlation_volumes:
            correlation_volume_file = find_correlation_volume_file(
                tomogram_file=Path(tomogram.name),
                correlation_volume_files=correlation_volume_files
            )
            console.log(f"loading correlation volume from {correlation_volume_file}")
            correlation_volume = mrcfile.read(correlation_volume_file)
            console.log(f"correlation volume loaded")

            # load particle positions and cc values
            console.log(f"loading particle metadata...")
            zyx, cc = get_particle_positions_and_cc(tomogram.name, particle_files=particle_files)
            console.log(f"particle metadata loaded")

            # notify user of max cc
            ts_id = Path(tomogram.name).name
            napari.utils.notifications.show_info(f"max cc for {ts_id} is {cc.max()}")

            # Update volumes in viewer
            if load_volumes is True:
                update_volume_layers(viewer, volume, correlation_volume, load_volumes=True)

            # Update particles
            update_particle_layer(viewer, zyx, cc, tomogram.name)
        else:
            console.log(f"loading particle metadata...")
            zyx = get_absolute_particle_positions(tomogram.name, particle_files=particle_files)
            console.log(f"particle metadata loaded")

            if load_volumes is True:
                # voxels = volume.size
                # estimated_bytes = voxels * 4  # float32
                # if estimated_bytes > 2000000000:  # 2GB threshold
                #     console.log(f"tomogram's size too big, downsampling to uint8...")
                #     mn, mx = volume.min(), volume.max()
                #     if mx > mn:
                #         volume = ((volume - mn) / (mx - mn) * 255).astype(np.uint8)
                #     else:
                #         volume = volume.astype(np.uint8)
                console.log(f"binning coordinates to {bin}...")
                volume = volume[::bin, ::bin, ::bin]  # default: 2

                if 'tomogram' not in viewer.layers:
                    viewer.add_image(data=volume, name='tomogram', colormap='gray_r')
                else:
                    viewer.layers['tomogram'].data = volume

            if 'particles' not in viewer.layers:
                viewer.add_points(
                    zyx / bin,
                    name='particles',
                    size=40 / bin,
                    metadata={
                        'positions': zyx / bin,
                        'ts_id': tomogram.name
                    },
                    face_color='orange',
                    opacity=0.5,
                    out_of_slice_display=True,
                )
            else:
                viewer.layers['particles'].data = zyx / bin
                viewer.layers['particles'].metadata['positions'] = zyx / bin
                viewer.layers['particles'].metadata['ts_id'] = tomogram.name

    # create interactive widget for subsetting particles
    @magicgui(auto_call=True)
    def subset_particles(min_cc: float = 0.0):
        cc = viewer.layers['particles'].metadata['cc']
        zyx = viewer.layers['particles'].metadata['positions']
        zyx = zyx[cc >= min_cc]
        viewer.layers['particles'].data = zyx

    # add widgets for changing tomogram and subsetting particles to viewer
    viewer.window.add_dock_widget(add_tomogram, area='bottom')
    if load_correlation_volumes:
        viewer.window.add_dock_widget(subset_particles, area='bottom')

    # initialise widget and launch viewer
    add_tomogram()
    napari.run()
